# CSIlluminated
计算机科学概论读书笔记

## 第一章 全景图

### 1.1 计算系统

#### 1.1.1 计算系统的分层

​	由内向外为：

1. 信息层
2. 硬件层
3. 程序设计层
4. 操作系统层
5. 应用程序层
6. 通信层

#### 1.1.2 抽象

​	我们分析的计算系统的层次是抽象的一种例子。所谓抽象，是一种心理模型，是一种思考事情的方式，它删除或隐藏了复杂的细节。抽象是计算的关键。

### 1.2 计算的历史

#### 1.2.1 计算硬件简史

##### 第一代 1951-1959

​	第一代商用计算机使用*真空管*存储信息。它会大量生热，不是非常可靠。使用真空管的机器需要重型空气调节装置以及不断地维修。

##### 第二代 1959-1965

`	晶体管`的出现标志着第二代商用计算机的诞生。晶体管代替真空管成为计算机硬件的主要部件。他比真空管更小、更可靠、更快、寿命更长，也更便宜。

##### 第三代 1965-1971

​	在第二代计算机中，晶体管个其他计算机元件都被手工集成在印刷电路班上。第三代计算机的特征是集成电路，这是一种具有晶体管和其他元件以及他们的连线的硅片。集成电路比印刷电路小，它更便宜、更快并且更可靠。

##### 第四代 1971-至今

​	大规模集成化是第四代的特征。

#### 1.2.2 计算软件简史

##### 第一代软件 1951-1959

​	第一代程序是用机器语言编写的。所谓机器语言，即内置在计算机电路中的指令。用机器语言进行程序设计不仅耗时，而且容易出错。由于编写及其代码非常乏味，有些程序设计员就开发了一些工具辅助程序设计。因此，第一代人工程序设计语言出现了。这些语言被称为汇编语言，它们使用助记忆码表示每条机器语言指令。

​	那些编写辅助工具的程序设计员简化了他人的程序设计，是最初的系统程序员。

##### 第二代软件 1959-1965

​	当硬件变得更强大时，就需要更强大的工具有效的使用他们。第二代软件见证了更强的语言开发。使用高级语言，程序设计员就能够用类似于英语的语句编写指令。

​	在第二代软件末期，系统程序员的角色变得更加明显。系统程序员编写诸如汇编器和编译器这样的工具，使用这些工具编写程序的人被称为应用程序设计员。随着包围硬件的软件变的越来越复杂，应用程序设计员离计算机硬件越来越远了。

##### 第三代软件 1965-1971

​	在前两代软件时期，实用程序用于处理频繁执行的任务。装入器把程序载入内存，连接器则把大型程序连接在一起。第三代软件改进了这些实用程序，使它们处于操作系统的引导之下。

​	起初，计算机用户和程序设计员是一体的。在第一代软件末期，为其他程序设计员编写工具的程序设计员的出现带来了系统程序设计员和应用程序设计员的区分。但是，程序设计员仍然是用户。在第三代软件中，系统程序员为其他人编写软件工具。计算机用户的概念骤然出现了，他们不再是传统意义上的程序员。

##### 第四代软件 1971-1989

​	20世纪70年代出现了更好的程序设计技术，即结构化程序设计方法，这是一种有逻辑、有规则的程序设计方法。此外，还出现了C语言，使用这种语言，用户可以在高级程序中使用一些汇编语句。

​	更好、更强大的操作系统也被开发出来了。

##### 第五代软件 1990-至今

​	第五代中有三个著名事件，即在计算机软件业具有主导地位的Microsoft公司的崛起、面向对象的设计和编程方法的出现以及万维网的普及。

​	第五代软件最重要的特征是用户概念的改变。首先出现的用户是程序设计员，他们编写程序来解决自己或他人的问题。接下来出现的用户是系统程序员，他们为其他程序员编写越来越复杂的工具。到20世纪70年代早期，应用程序员使用这些复杂的工具为非程序员编写应用程序。

### 1.3 计算工具与计算学科

​	对于那些工具制作者来说，计算是一种学科（低级工具），或者计算这种学科使他们的工具成为可行的（将一种应用程序构建在另一种应用程序之上）。

​	学科被定义为一种学习领域。

## 第二章 二进制数值与计数系统

### 2.1 数字与计算

### 2.2 位置记数法

	>基数：技术系统的基本数值，规定了这个系统中使用的数字量和数位位置的值

​	2进制的基数就是2，8进制的基数就是8以此类推

> 位置计数法：一种表达数字的系统，数位按顺序排序，每个数位都有一个位值，数字的值是每个数位和位值的乘积

#### 2.2.1 二进制、八进制和十六进制

​	任何计数系统中的最大数字比基数小1。要用任何基数表示计数值，只需要两个数字。0位于最右边，1在0的左边，这个数字表示基数值本身。

#### 2.2.2 其他记数系统中的运算

#### 2.2.3 以2的幂为基数的记数系统

​	把二进制转换成八进制只需要**从右往左**每三位一组，把每组数字转换成相应的八进制数。

> 11101100 转换成 011 101 100 对应的八进制 为
>
> 011: 3 , 101: 5, 100: 4 所以八进制为： 354

把八进制转换为二进制 只需要把每个数字转换成三位一组的二进制即可

---

​	二进制和十六进制的转换和八进制是一样的道理，只需要四位一组即可。

​	二进制可以和他们快速转换的原因在于8或16是2的幂。

#### 2.2.4 把十进制数转换成其他数制的数

​	用十进制数除以基数，得到商和余数，重复这一步骤知道商为0。转换的结果就是由下往上余数代表的对应的其他数制的值。

​	exp: 将十进制数161转换成16进制

​	161/16 = 10余1

​	10/16 = 0余10 结果为 A1

#### 2.2.5 二进制数值与计算机	

​	计算机中的所有信息都是用二进制数值表示的，原因在于计算机中的每个存储位只有高电平和低电平两种信号。

​	每个存储单元称为一个二进制数字，简称位。

## 第三章 数据表示法

### 目标

- 区分模拟数据和数字数据

  ​	模拟数据是一种连续表示法，模拟它表示的真实信息。数字数据是一种离散表示法，把信息分割成了独立的元素。

- 解释数据压缩和计算压缩率

  ​	数据压缩就是减少存储一段数据所需的空间。压缩率说明了压缩的程度，是压缩后的数据大小除以原始数据大小的值。压缩率的单位可以是任意的。压缩率是一个0到1之间的数。压缩率越接近0，压缩程度越高。

- 解释负数和浮点数的二进制格式

  ​	假定我们限制位数为8位，则有0-255个数字用来表示正负数。我们用00000000到01111111表示正数的0-127用11111111到10000000表示负数的-1到-128。负数的最左边一位用来表示这是负数。如果要将正数变为负数只需要对每一位取反再加1。这种表示法称为二进制补码。

  ​	十进制中的浮点数转换为二进制需要用这个数乘以2得到一个数，这个数的小数点左边就是第一位结果，右边是新的基数，用新基数不断乘以2，直至乘法结果中的小数部分为0。

  exp: 20.25 转换为二进制为

  20 -> 2进制 = 10100

  0.25 -> 2进制 = 0.25 * 2 = 0.5

  ​			= 0.5 * 2 = 1.0

  ​			= 10100.01

- 描述ASCII和Unicode字符集的特征

  ​	ASCII字符集用8位表示每个字符，所以一共可以表示256个字符。虽然足够表示英语，但是却无法满足国际需要。而Unicode把ASCII字符集作为了一个子集，每个字符的编码都为16位。为了保持一致，Unicode字符集被设计为ASCII的超集。也就是说Unicode字符集中的前256个字符与扩展ASCII字符集中的完全一致。

- 解释声音的本质和它的表示法

  ​	当一系列空气压缩震动我们的耳膜时，会给我们的大脑发送一些信号，我们就感觉到了声音。因此，声音实际上是由于我们的耳膜交互的声波定义的。要表示声音，必须正确地表示声波。

  ​	要在计算机上表示音频数据，必须数字化声波，把它分割成离散的、便于管理的片段。方法之一是真正数字化声音的模拟表示法。也就是说，采集表示声波的电信号，并用一系列离散的数值表示它。

- 解释RGB值如何定义颜色

  ​	在计算机中，颜色通常用RGB表示，这其实是三个数字，说明了每种原色相对份额。如果用0到255的数字表示一种元素的份额，那么0表示这种颜色没有参与，255表示它完全参与其中。

- 区分光栅图形和矢量图形

  ​	逐个像素存储图像信息的方法称为光栅图形格式。目前流行的几种光栅图形格式有位图（BMP）、GIF、JPEG。

  ​	矢量图形是一系列描述线段的方向、线宽和颜色的命令。由于不必记录所有的像素，所以采用这种格式的文件一般比较小。

- 解释时间和空间视频压缩

  ​	时间压缩：根据连续帧之间的差别压缩电影的技术

  ​	空间压缩：基于静态图像的压缩技术的电影压缩技术

## 第四章 门和电路

### 目标

- 识别基础的门并描述每种门的行为
  1. 与门：有0出0
  2. 或门：有1出1
  3. 非门：取反
  4. 异或门：相同出0，不同出1
  5. 与非门：有0出1
  6. 或非门：有1出0

- 描述如何用晶体管实现门

  ​	门使用晶体管建立输入值和输出值之间的映射。晶体管有三个接线端，即源极、基极和发射极，发射极通常被连接到地线。晶体管只能是开或关两种状态，由基极电信号决定。当基极信号是高电平，源极信号被接地、从而关闭了晶体管。如果基极信号是低电平，则源极信号是高电平，晶体管被打开。

  ​	非门的图解几乎与原始晶体管一样。与非门需要两个晶体管上面一个晶体管的发射极接到下面一个的源极。或非门的两个晶体管使用一个源极信号。在与非门和或非门再加上一个非门就有了与门和非门。

- 比较半加器和全加器之间的异同点

  ​	半加器有一个与门和异或门组成，只能执行两位数的和。求和是异或门，执行进位的是与门。

  ​	半加器能产生进位但是不能处理进位，而全加器可以。它们本质上是一样的，只是全加器比半加器多一个接收进位的输入端，这样全加器每一次都要考虑来自低位的进位，而半加器不用考虑，直接把两个二进制数相加就行。

- 描述多路复用器是如何运作的

  ​	多路复用器根据称为选择信号或选择控制线的输入信号选择用哪个输入信号作为输出信号。

  > 多路复用器：使用一些输入控制信号决定用那些输入数据线发送输出信号的电路

  ​	假设有一个多路复用器有三条控制线S0，S1，S2，有八条输入线D0-D7。因为三条控制线被译为一个二进制数，所以三条控制线就有八种控制输入的方式(2的3次方)。如果三条线都是0，那么控制的就是D0，其他的同理。

- 解释如何操作S-R锁存器

  ​	初始化S为0R为1，则X就为1，当S变为1，S-R锁存器将保持1的状态。把R设置为0S为1，则Y为1，当R变为1，电路保持-的状态。如果S和R都为1无论当前存储的值是什么，电路就保持为当前状态。

- 描述四代集成电路的特征

  ​	VLSI（超大规模集成）芯片上的门不像小规模集成电路中的门一样，它们不是独立的。VLSI芯片上嵌入的电路具有很高的门-引脚比。也就是说，许多门被组合在一起，创建的复杂电路只需要很少的输入和输出值。多路复用器是这种电路的一个例子。

## 第五章 计算部件

### 目标

- 列出冯诺依曼机的部件和他们的功能

  1. 存放数据和指令的内存单元

     ​	内存是存储单元的集合，每个存储单元有一个唯一的物理地址

  2. 对数据执行算数和逻辑运算的算数逻辑单元

     ​	算数逻辑运算单元能执行基本的算术运算和逻辑运算。ALU操作的是字，即与特定计算机设计相关联的数据的自然单位。大多数现代ALU都有少量的特殊存储单元，称为寄存器。寄存器能容纳一个字，用户存放立刻会被再次用到的信息。

  3. 把数据从外部世界转移到计算机中的输入单元

  4. 把结果从计算及内部转移到外部世界的输出单元

  5. 担当舞台监督，确保其他部件都参与了表演的控制单元

     ​	控制单元掌管着读取 **-** 执行周期，因此是计算机中的组织力量。由于ALU和控制单元的协作非常紧密，所以他们常常被看作一个单元，被称为中央处理器（CPU）

- 描述冯诺依曼机的读取 **-** 译解 **-** 执行周期

  处理周期中的四个步骤如下：

  - 读取下一条指令

    ​	程序计数器存放的是下一条要执行的指令的地址，因此控制单元将访问程序计数器中指定的内存地址，复制其中的内容，把副本放入指令寄存器中。此时，指令寄存器存放的是将要执行的指令。在进入周期中的下一步之前，必须更新程序计数器，使他存放当前指令完成时要执行的下一条指令的地址。**由于指令连续存储在内存中，所以给程序计数器加1就可以吧吓一跳指令的地址存入程序计数器。因此，控制单元将把程序计数器加1.也可能在指令执行完之后才更改程序计数器。**

  - 译解指令

    ​	为了执行指令寄存器中的指令，控制单元必须确定他是什么指令。**在这一阶段，指令将被译解成控制型号。也就是说，CPU中的电路逻辑将决定执行什么操作。指令本身被逐字地嵌入了电路。**

  - 如果需要，获取数据

    ​	被执行的指令要完成它的任务，可能需要额外的内存访问。例如，如果一条指令要把某个内存单元中的内容装入寄存器，控制单元就必须得到这个内存单元的内容。

  - 执行指令

    ​	一旦译解了指令并且读取了操作数（数据），控制单元就为执行指令做好了准备。执行指令要把信号发送给算术逻辑单元以执行处理。当执行完成时，下一个周期开始。

- 描述如何组织和访问计算机内存
- 命名并描述不同的辅助存储设备
  1. 磁带
  2. 磁盘
  3. CD\DVD
  4. 闪存（U盘）

- 解释嵌入式系统的概念

  ​	现在这一术语指代任一预编程的、为了完成某一特殊用途的、作为大型系统一部分的计算机。这意味着终端用户或操作员极少干预嵌入式系统的运行。

  ​	在实际情况中，程序必须编写并烧入在系统包含的只读内存中，这样嵌入式系统才能完成指定的功能。**程序不能在嵌入式处理其本身之中开发和测试，程序是在台式机中编写的，并且会根据目标系统进行编译，根据嵌入式系统的处理器生成可执行代码。**

## 第六章 低级程序设计语言与伪代码

### 目标

- 列出计算机能够执行的操作

  ​	计算机是能够*存储*、*检索*和*处理*数据的*可编程*电子设备

- 描述虚拟机Pep/8的重要特性

  ​	Pep/8的内存单元由65536字节的存储空间构成。它的字长是2字节，或者16比特。这样向算数/逻辑单元（ALU）流入的数据或从算数/逻辑单元流出的数据在长度上就是16比特。Pep/8有七个寄存器。

- 区分立即寻址模式和直接寻址模式

  ​	如果殉职模式是000，那么指令的操作数说明符中存储的就是操作数。这种殉职模式称为立即寻址（i）。如果寻址模式是001，那么操作数说明符中存储的是操作数所在的内存地址名称。这种寻址模式称为直接寻址（d）。

- 区分机器语言和汇编语言

  ​	汇编语言给每条机器语言指令分配了一个助记指令码，程序员可以用这些指令码代替二进制数字。因为在计算机上执行的每个程序最终都要被翻译成机器语言的形式，所以一个名为汇编器的程序将读取每条指令的助记码，然后把它翻译成等价的机器语言。因为每种类型的计算机都有自己的机器语言，所以有多少种机器，就有多少种汇编语言和翻译程序。

## 第七章 问题求解与算法设计

- 选择排序

  ​	给一个初始下标值，假定数组中的第一个元素是最小的，依次和其他元素比较，如果其他元素比第一个元素小，就记录该元素的索引，直到找到最小的一个元素的索引。交换最小的元素和第一个元素的位置，并且初始下标+1。初始下标移动小于数组的长度-1。

  ```Java
  	int firstUnsorted = 0;
  	while (firstUnsorted < length - 1) {
  		int indexOfSmallestItem = smallestItem(firstUnsorted);
          swap(firstUnsorted, indexOfSmallestItem);
          firstUnsorted++;
  	}
  ```

- 冒泡排序

  ​	冒泡排序从数组的最后一个元素开始，比较相邻的元素对，如果下面的元素小与上面的元素，就交换这两个元素的位置。通过这种方法，最小的元素会“冒”到数组的顶部。每次迭代都会把未排序的最小元素放到它的正确位置，不过这同时会改变数组中其他元素的位置。

- 插入排序
- 快速排序

## 第八章 抽象数据类型与子程序

- 栈

  ​	栈是一种抽象复合结构，只能从一端访问栈中的元素。会计师称为LIFO，即后进先出。把栈比作自助餐厅的餐具架，使他的插入和删除操作有了个惯用语，插入操作叫Push，删除操作叫Pop。我们把项目推进栈，从栈中弹出项目。栈没有长度数学，所以没有返回栈中项目个数的操作。我们需要的是确定栈是否为空(isEmpty)的操作，因为当栈为空的时候在弹出项目会报错。

- 队列

  ​	队列也是种抽象结构，队列中的项目从一端入，从另一端出。会计师称为FIFO，即先进先出。插入操作在队列的尾部进行，删除操作在队列的头部进行。与栈一样，插入操作没有任何约束；整个FIFO行为都体现在删除操作上。

- 列表

  ​	列表有三个属性特征：项目是同构的，项目是线性的，列表是变长的。不要把列表误认为是数组，数组是内嵌结构，列表式抽象结构。

- 二叉树

  ​	二叉树是一种抽象结构，其中每个节点可以有两个后继节点，叫做子女。每个子女任然是二叉树的节点，因此也可以有两子节点，而这些子女又可以有自己的子女，以此类推，这就形成了树的分支结构。树的头部是一个起始节点，叫做根，它不是任何节点的子女。除了规定每个节点至多有两个子女外，二叉树的定义还说明了根节点和每个节点之间有且只有一条路径。这就是说，除了根节点外，，每个节点都只有一个父母节点。

- 二叉搜索树

  ​	二叉搜索树具有二叉树的形状属性。此外，二叉搜索树还具有语义属性来刻画树中节点上的值，即任何节点的值都要大于它的左子树中的所有节点的值，并且要小于它的右子树中的所有节点的值。

- 图

  ​	树是表示存在的体系结构中关系的有效方式，也就是说，一个节点至多只有一个指向它的节点。如果去掉这种约束，就得到了另一种数据结构 **-** 图。图有一组节点和连接节点的线段构成，图中的节点叫做顶点，图中的线段叫做边。图中用的定点表示对象，边则描述了定点之间的关系。

- 值参与引用参数

  ​	如果一个形参是值参，调用单元将把实参的一个副本传递给子程序。如果一个形参是引用参数，调用单元将把实参的地址传递给子程序。这意味着，由于子程序接受的只是实参的一个副本，因此它不能改变实参的内容，而只能修改副本，不会改变原始变量。相反，子程序可以改变调用单元传递给引用参数的任何实参，因为子程序操作的是实际变量，而不是变量的副本。

> Java中都是值参

## 第九章 面向对象设计与高级程序设计语言

- 编译器

  ​	*翻译用高级程序设计语言编写的程序*的程序叫做编译器。早期编译器输出的是程序的汇编语言版本，这个版本还要经过汇编器处理才能得到可执行的机器语言程序。随着计算机科学该更加深入地了解翻译过程，编译器变得更加复杂，汇编语言的阶段通常被省略了。

  ​	任何计算机只要具有一种高级语言的编译器，就能运行用种语言编写的程序。注意，编译器是一种程序，因此，要编译一个程序，就必须具有这个编译器在特定机器上的机器码版本。

- 解释器

  ​	解释器是一种程序，用于翻译和执行语句序列，解释器在翻译过语句之后会立即执行这个语句。

  > ​	Java的设计中，可移植性是最重要的特性。为了达到最佳可移植性，Java被编译成一种标准机器语言 **—** 字节码。一种名为JVM的软件解释器接收字节码程序，然后执行它。也就是说，字节码不是某个特定硬件处理器的机器语言，任何具有JVM的机器都可以运行编译过的Java程序。
  >
  > ​	用高级语言编写的程序能够在任何具有适合的编译器的机器上编译和运行，程序将被翻译成计算机能够直接执行的机器码。而Java程序则是被编译成字节码，编译过的字节码程序可以在任何具有JVm解释器的机器上运行。也就是说，Java编译器输出的程序将被解释，而不是直接被执行。Java程序总是被翻译成字节码。

- 命令式泛型

  ​	命令式泛型具有顺序执行指令的特征，变量的使用代表了内存地址，而是用赋值语句则改变这些变量的值。

- 声明式泛型

  ​	声明式泛型是一个描述结果的模型，但是完成结果的过程则不被描述。

